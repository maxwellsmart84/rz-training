'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _QueryBuilderOperation = require('./QueryBuilderOperation');

var _QueryBuilderOperation2 = _interopRequireDefault(_QueryBuilderOperation);

var _promiseUtils = require('../../utils/promiseUtils');

var _dbUtils = require('../../utils/dbUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var InsertOperation = function (_QueryBuilderOperatio) {
  (0, _inherits3.default)(InsertOperation, _QueryBuilderOperatio);

  function InsertOperation(builder, name, opt) {
    (0, _classCallCheck3.default)(this, InsertOperation);

    var _this = (0, _possibleConstructorReturn3.default)(this, _QueryBuilderOperatio.call(this, builder, name, opt));

    _this.models = null;
    _this.isArray = false;
    _this.modelOptions = _this.opt.modelOptions || {};
    _this.isWriteOperation = true;
    return _this;
  }

  InsertOperation.prototype.call = function call(builder, args) {
    this.isArray = _lodash2.default.isArray(args[0]);
    this.models = builder.modelClass().ensureModelArray(args[0], this.modelOptions);
    return true;
  };

  InsertOperation.prototype.onBeforeInternal = function onBeforeInternal(builder, result) {
    if (this.models.length > 1 && !(0, _dbUtils.isPostgres)(this.knex)) {
      throw new Error('batch insert only works with Postgresql');
    } else {
      return (0, _promiseUtils.mapAfterAllReturn)(this.models, function (model) {
        return model.$beforeInsert(builder.context());
      }, result);
    }
  };

  InsertOperation.prototype.onBuild = function onBuild(knexBuilder, builder) {
    if (!builder.has(/returning/)) {
      // If the user hasn't specified a `returning` clause, we make sure
      // that at least the identifier is returned.
      knexBuilder.returning(builder.modelClass().idColumn);
    }

    knexBuilder.insert(_lodash2.default.map(this.models, function (model) {
      return model.$toDatabaseJson();
    }));
  };

  InsertOperation.prototype.onAfterQuery = function onAfterQuery(builder, ret) {
    if (!_lodash2.default.isArray(ret) || _lodash2.default.isEmpty(ret) || ret === this.models) {
      // Early exit if there is nothing to do.
      return this.models;
    }

    if (_lodash2.default.isObject(ret[0])) {
      // If the user specified a `returning` clause the result may be an array of objects.
      // Merge all values of the objects to our models.
      _lodash2.default.each(this.models, function (model, index) {
        return model.$set(ret[index]);
      });
    } else {
      // If the return value is not an array of objects, we assume it is an array of identifiers.
      _lodash2.default.each(this.models, function (model, idx) {
        // Don't set the id if the model already has one. MySQL and Sqlite don't return the correct
        // primary key value if the id is not generated in db, but given explicitly.
        if (!model.$id()) {
          model.$id(ret[idx]);
        }
      });
    }

    return this.models;
  };

  InsertOperation.prototype.onAfterInternal = function onAfterInternal(builder, models) {
    var result = this.isArray ? models : models[0] || null;
    return (0, _promiseUtils.mapAfterAllReturn)(models, function (model) {
      return model.$afterInsert(builder.context());
    }, result);
  };

  return InsertOperation;
}(_QueryBuilderOperation2.default);

exports.default = InsertOperation;