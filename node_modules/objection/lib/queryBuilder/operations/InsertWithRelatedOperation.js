'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _DelegateOperation2 = require('./DelegateOperation');

var _DelegateOperation3 = _interopRequireDefault(_DelegateOperation2);

var _InsertWithRelated = require('../InsertWithRelated');

var _InsertWithRelated2 = _interopRequireDefault(_InsertWithRelated);

var _dbUtils = require('../../utils/dbUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var InsertWithRelatedOperation = function (_DelegateOperation) {
  (0, _inherits3.default)(InsertWithRelatedOperation, _DelegateOperation);

  function InsertWithRelatedOperation(builder, name, opt) {
    (0, _classCallCheck3.default)(this, InsertWithRelatedOperation);


    // Our delegate method inherits from `InsertRelation`. Disable the call-time
    // validation. We do the validation in onAfterQuery instead.

    var _this = (0, _possibleConstructorReturn3.default)(this, _DelegateOperation.call(this, builder, name, opt));

    _this.delegate.modelOptions.skipValidation = true;
    return _this;
  }

  InsertWithRelatedOperation.prototype.call = function call(builder, args) {
    var retVal = _DelegateOperation.prototype.call.call(this, builder, args);

    // We resolve this query here and will not execute it. This is because the root
    // value may depend on other models in the graph and cannot be inserted first.
    builder.resolve([]);

    return retVal;
  };

  InsertWithRelatedOperation.prototype.onBefore = function onBefore() {
    // Do nothing.
  };

  InsertWithRelatedOperation.prototype.onBeforeInternal = function onBeforeInternal() {
    // Do nothing. We override this with empty implementation so that
    // the $beforeInsert() hooks are not called twice for the root models.
  };

  InsertWithRelatedOperation.prototype.onBeforeBuild = function onBeforeBuild() {
    // Do nothing.
  };

  InsertWithRelatedOperation.prototype.onBuild = function onBuild() {}
  // Do nothing.


  // We overrode all other hooks but this one and do all the work in here.
  // This is a bit hacky.
  ;

  InsertWithRelatedOperation.prototype.onAfterQuery = function onAfterQuery(builder) {
    var _this2 = this;

    var ModelClass = builder.modelClass();
    var batchSize = (0, _dbUtils.isPostgres)(ModelClass.knex()) ? 100 : 1;

    var inserter = new _InsertWithRelated2.default({
      modelClass: ModelClass,
      models: this.models,
      allowedRelations: builder._allowedInsertExpression || null
    });

    return inserter.execute(function (tableInsertion) {
      var insertQuery = tableInsertion.modelClass.query().childQueryOf(builder);

      // We skipped the validation above. We need to validate here since at this point
      // the models should no longer contain any special properties.
      _lodash2.default.each(tableInsertion.models, function (model) {
        model.$validate();
      });

      var inputs = _lodash2.default.filter(tableInsertion.models, function (model, idx) {
        return tableInsertion.isInputModel[idx];
      });

      var others = _lodash2.default.filter(tableInsertion.models, function (model, idx) {
        return !tableInsertion.isInputModel[idx];
      });

      return _promise2.default.all(_lodash2.default.flatten([batchInsert(inputs, insertQuery.clone().copyFrom(builder, /returning/), batchSize), batchInsert(others, insertQuery.clone(), batchSize)]));
    }).then(function () {
      return _DelegateOperation.prototype.onAfterQuery.call(_this2, builder, _this2.models);
    });
  };

  InsertWithRelatedOperation.prototype.onAfterInternal = function onAfterInternal() {
    // We override this with empty implementation so that the $afterInsert() hooks
    // are not called twice for the root models.
    return this.isArray ? this.models : this.models[0] || null;
  };

  (0, _createClass3.default)(InsertWithRelatedOperation, [{
    key: 'models',
    get: function get() {
      return this.delegate.models;
    }
  }, {
    key: 'isArray',
    get: function get() {
      return this.delegate.isArray;
    }
  }]);
  return InsertWithRelatedOperation;
}(_DelegateOperation3.default);

exports.default = InsertWithRelatedOperation;


function batchInsert(models, queryBuilder, batchSize) {
  var batches = _lodash2.default.chunk(models, batchSize);
  return _lodash2.default.map(batches, function (batch) {
    return queryBuilder.clone().insert(batch);
  });
}