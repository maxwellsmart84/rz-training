'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _desc, _value, _class;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _memoize = require('../utils/decorators/memoize');

var _memoize2 = _interopRequireDefault(_memoize);

var _classUtils = require('../utils/classUtils');

var _QueryBuilder = require('../queryBuilder/QueryBuilder');

var _QueryBuilder2 = _interopRequireDefault(_QueryBuilder);

var _RelationFindOperation = require('./RelationFindOperation');

var _RelationFindOperation2 = _interopRequireDefault(_RelationFindOperation);

var _RelationUpdateOperation = require('./RelationUpdateOperation');

var _RelationUpdateOperation2 = _interopRequireDefault(_RelationUpdateOperation);

var _RelationDeleteOperation = require('./RelationDeleteOperation');

var _RelationDeleteOperation2 = _interopRequireDefault(_RelationDeleteOperation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * @typedef {Object} RelationJoin

 * @property {string|Array.<string>} from
 * @property {string|Array.<string>} to
 * @property {Object} through
 * @property {Constructor.<Model>} through.modelClass
 * @property {string|Array.<string>} through.from
 * @property {string|Array.<string>} through.to
 * @property {Array.<string>} through.extra
 */

/**
 * @typedef {Object} RelationMapping
 *
 * @property {Constructor.<Model>|string} modelClass
 * @property {Relation} relation
 * @property {Object|function(QueryBuilder)} filter
 * @property {RelationJoin} [join]
 */

/**
 * @abstract
 */
var Relation = (_class = function () {
  function Relation(relationName, OwnerClass) {
    (0, _classCallCheck3.default)(this, Relation);

    /**
     * @type {string}
     */
    this.name = relationName;

    /**
     * @type {Constructor.<Model>}
     */
    this.ownerModelClass = OwnerClass;

    /**
     * @type {Constructor.<Model>}
     */
    this.relatedModelClass = null;

    /**
     * @type {Array.<string>}
     */
    this.ownerCol = null;

    /**
     * @type {Array.<string>}
     */
    this.ownerProp = null;

    /**
     * @type {Array.<string>}
     */
    this.relatedCol = null;

    /**
     * @type {Array.<string>}
     */
    this.relatedProp = null;

    /**
     * @type {function (QueryBuilder)}
     */
    this.filter = null;
  }

  /**
   * @param {function=} subclassConstructor
   * @return {Constructor.<Model>}
   */


  Relation.extend = function extend(subclassConstructor) {
    (0, _classUtils.inherits)(subclassConstructor, this);
    return subclassConstructor;
  };

  /**
   * @param {RelationMapping} mapping
   */


  Relation.prototype.setMapping = function setMapping(mapping) {
    // Avoid require loop and import here.
    var Model = require(__dirname + '/../model/Model').default;

    if (!(0, _classUtils.isSubclassOf)(this.ownerModelClass, Model)) {
      this.throwError('Relation\'s owner is not a subclass of Model');
    }

    if (!mapping.modelClass) {
      this.throwError('modelClass is not defined');
    }

    if (_lodash2.default.isString(mapping.modelClass)) {
      try {
        // babel 6 style of exposing es6 exports to commonjs https://github.com/babel/babel/issues/2683
        var relatedModelClassModule = require(mapping.modelClass);
        this.relatedModelClass = (0, _classUtils.isSubclassOf)(relatedModelClassModule.default, Model) ? relatedModelClassModule.default : relatedModelClassModule;
      } catch (err) {
        this.throwError('modelClass is an invalid file path to a model class.');
      }

      if (!(0, _classUtils.isSubclassOf)(this.relatedModelClass, Model)) {
        this.throwError('modelClass is a valid path to a module, but the module doesn\'t export a Model subclass.');
      }
    } else {
      this.relatedModelClass = mapping.modelClass;

      if (!(0, _classUtils.isSubclassOf)(this.relatedModelClass, Model)) {
        this.throwError('modelClass is not a subclass of Model or a file path to a module that exports one.');
      }
    }

    if (!mapping.relation) {
      this.throwError('relation is not defined');
    }

    if (!(0, _classUtils.isSubclassOf)(mapping.relation, Relation)) {
      this.throwError('relation is not a subclass of Relation');
    }

    if (!mapping.join || !mapping.join.from || !mapping.join.to) {
      this.throwError('join must be an object that maps the columns of the related models together. For example: {from: "SomeTable.id", to: "SomeOtherTable.someModelId"}');
    }

    var joinOwner = null;
    var joinRelated = null;

    var joinFrom = this.parseReference(mapping.join.from);
    var joinTo = this.parseReference(mapping.join.to);

    if (!joinFrom.table || _lodash2.default.isEmpty(joinFrom.columns)) {
      this.throwError('join.from must have format TableName.columnName. For example "SomeTable.id" or in case of composite key ["SomeTable.a", "SomeTable.b"].');
    }

    if (!joinTo.table || _lodash2.default.isEmpty(joinTo.columns)) {
      this.throwError('join.to must have format TableName.columnName. For example "SomeTable.id" or in case of composite key ["SomeTable.a", "SomeTable.b"].');
    }

    if (joinFrom.table === this.ownerModelClass.tableName) {
      joinOwner = joinFrom;
      joinRelated = joinTo;
    } else if (joinTo.table === this.ownerModelClass.tableName) {
      joinOwner = joinTo;
      joinRelated = joinFrom;
    } else {
      this.throwError('join: either `from` or `to` must point to the owner model table.');
    }

    if (joinRelated.table !== this.relatedModelClass.tableName) {
      this.throwError('join: either `from` or `to` must point to the related model table.');
    }

    this.ownerCol = joinOwner.columns;
    this.ownerProp = this.propertyName(this.ownerCol, this.ownerModelClass);
    this.relatedCol = joinRelated.columns;
    this.relatedProp = this.propertyName(this.relatedCol, this.relatedModelClass);
    this.filter = this.parseFilter(mapping);
  };

  /**
   * @returns {knex}
   */


  Relation.prototype.knex = function knex() {
    return this.ownerModelClass.knex();
  };

  /**
   * @returns {Array.<string>}
   */


  Relation.prototype.fullOwnerCol = function fullOwnerCol() {
    var _this = this;

    return _lodash2.default.map(this.ownerCol, function (col) {
      return _this.ownerModelClass.tableName + '.' + col;
    });
  };

  /**
   * @returns {Array.<string>}
   */


  Relation.prototype.fullRelatedCol = function fullRelatedCol() {
    var _this2 = this;

    return _lodash2.default.map(this.relatedCol, function (col) {
      return _this2.relatedModelClass.tableName + '.' + col;
    });
  };

  /**
   * @returns {string}
   */


  Relation.prototype.relatedTableAlias = function relatedTableAlias() {
    return this.relatedModelClass.tableName + '_rel_' + this.name;
  };

  /**
   * @returns {Relation}
   */


  Relation.prototype.clone = function clone() {
    var relation = new this.constructor(this.name, this.ownerModelClass);

    relation.relatedModelClass = this.relatedModelClass;
    relation.ownerCol = this.ownerCol;
    relation.ownerProp = this.ownerProp;
    relation.relatedCol = this.relatedCol;
    relation.relatedProp = this.relatedProp;
    relation.filter = this.filter;

    return relation;
  };

  /**
   * @param {knex} knex
   * @returns {Relation}
   */


  Relation.prototype.bindKnex = function bindKnex(knex) {
    var bound = this.clone();

    bound.relatedModelClass = this.relatedModelClass.bindKnex(knex);
    bound.ownerModelClass = this.ownerModelClass.bindKnex(knex);

    return bound;
  };

  /**
   * @param {QueryBuilder} builder
   * @param {Array.<string>|Array.<Array.<(string|number)>>} ownerIds
   * @param {boolean=} isColumnRef
   * @returns {QueryBuilder}
   */


  Relation.prototype.findQuery = function findQuery(builder, ownerIds, isColumnRef) {
    var fullRelatedCol = this.fullRelatedCol();

    if (isColumnRef) {
      _lodash2.default.each(fullRelatedCol, function (col, idx) {
        builder.whereRef(col, ownerIds[idx]);
      });
    } else {
      if ((0, _lodash2.default)(ownerIds).flatten().every(function (id) {
        return _lodash2.default.isNull(id) || _lodash2.default.isUndefined(id);
      })) {
        // Nothing to fetch.
        builder.resolve([]);
      } else {
        builder.whereInComposite(fullRelatedCol, ownerIds);
      }
    }

    return builder.modify(this.filter);
  };

  /**
   * @param {QueryBuilder} builder
   * @param {string=} joinOperation
   * @param {string=} relatedTableAlias
   * @returns {QueryBuilder}
   */


  Relation.prototype.join = function join(builder, joinOperation, relatedTableAlias) {
    joinOperation = joinOperation || 'join';
    relatedTableAlias = relatedTableAlias || this.relatedTableAlias();

    var relatedTable = this.relatedModelClass.tableName;
    var relatedTableAsAlias = relatedTable + ' as ' + relatedTableAlias;
    var relatedCol = _lodash2.default.map(this.relatedCol, function (col) {
      return relatedTableAlias + '.' + col;
    });
    var ownerCol = this.fullOwnerCol();

    return builder[joinOperation](relatedTableAsAlias, function (join) {
      _lodash2.default.each(relatedCol, function (relatedCol, idx) {
        join.on(relatedCol, '=', ownerCol[idx]);
      });
    }).modify(this.filter);
  };

  /* istanbul ignore next */
  /**
   * @abstract
   * @param {QueryBuilder} builder
   * @param {Model} owner
   * @returns {QueryBuilderOperation}
   */


  Relation.prototype.insert = function insert(builder, owner) {
    this.throwError('not implemented');
  };

  /**
   * @param {QueryBuilder} builder
   * @param {Model} owner
   * @returns {QueryBuilderOperation}
   */


  Relation.prototype.update = function update(builder, owner) {
    return new _RelationUpdateOperation2.default(builder, 'update', {
      relation: this,
      owner: owner
    });
  };

  /**
   * @param {QueryBuilder} builder
   * @param {Model} owner
   * @returns {QueryBuilderOperation}
   */


  Relation.prototype.patch = function patch(builder, owner) {
    return new _RelationUpdateOperation2.default(builder, 'patch', {
      relation: this,
      owner: owner,
      modelOptions: { patch: true }
    });
  };

  /**
   * @param {QueryBuilder} builder
   * @param {Array.<Model>} owners
   * @returns {QueryBuilderOperation}
   */


  Relation.prototype.find = function find(builder, owners) {
    return new _RelationFindOperation2.default(builder, 'find', {
      relation: this,
      owners: owners
    });
  };

  /**
   * @param {QueryBuilder} builder
   * @param {Model} owner
   * @returns {QueryBuilderOperation}
   */


  Relation.prototype.delete = function _delete(builder, owner) {
    return new _RelationDeleteOperation2.default(builder, 'delete', {
      relation: this,
      owner: owner
    });
  };

  /* istanbul ignore next */
  /**
   * @abstract
   * @param {QueryBuilder} builder
   * @param {Model} owner
   * @returns {QueryBuilderOperation}
   */


  Relation.prototype.relate = function relate(builder, owner) {
    this.throwError('not implemented');
  };

  /* istanbul ignore next */
  /**
   * @abstract
   * @param {QueryBuilder} builder
   * @param {Model} owner
   * @returns {QueryBuilderOperation}
   */


  Relation.prototype.unrelate = function unrelate(builder, owner) {
    this.throwError('not implemented');
  };

  /* istanbul ignore next */
  /**
   * @abstract
   * @protected
   */


  Relation.prototype.createRelationProp = function createRelationProp(owners, related) {
    this.throwError('not implemented');
  };

  /**
   * @protected
   */


  Relation.prototype.propertyName = function propertyName(columns, modelClass) {
    var _this3 = this;

    return _lodash2.default.map(columns, function (column) {
      var propertyName = modelClass.columnNameToPropertyName(column);

      if (!propertyName) {
        throw new Error(modelClass.name + '.$parseDatabaseJson probably transforms the value of the column ' + column + '.' + ' This is a no-no because ' + column + ' is needed in the relation ' + _this3.ownerModelClass.tableName + '.' + _this3.name);
      }

      return propertyName;
    });
  };

  /**
   * @protected
   */


  Relation.prototype.parseFilter = function parseFilter(mapping) {
    if (_lodash2.default.isFunction(mapping.filter)) {
      return mapping.filter;
    } else if (_lodash2.default.isObject(mapping.filter)) {
      return function (queryBuilder) {
        queryBuilder.where(mapping.filter);
      };
    } else {
      return _lodash2.default.noop;
    }
  };

  /**
   * @protected
   */


  Relation.prototype.parseReference = function parseReference(ref) {
    if (!_lodash2.default.isArray(ref)) {
      ref = [ref];
    }

    var table = null;
    var columns = [];

    for (var i = 0; i < ref.length; ++i) {
      var refItem = ref[i];
      var ndx = refItem.lastIndexOf('.');
      var tableName = refItem.substr(0, ndx).trim();
      var columnName = refItem.substr(ndx + 1, refItem.length).trim();

      if (!tableName || table && table !== tableName || !columnName) {
        return {
          table: null,
          columns: []
        };
      } else {
        table = tableName;
      }

      columns.push(columnName);
    }

    return {
      table: table,
      columns: columns
    };
  };

  /**
   * @protected
   */


  Relation.prototype.mergeModels = function mergeModels(models1, models2) {
    var modelsById = (0, _create2.default)(null);

    models1 = _lodash2.default.compact(models1);
    models2 = _lodash2.default.compact(models2);

    _lodash2.default.forEach(models1, function (model) {
      modelsById[model.$id()] = model;
    });

    _lodash2.default.forEach(models2, function (model) {
      modelsById[model.$id()] = model;
    });

    var models = _lodash2.default.values(modelsById);
    if (models.length === 0) {
      return [];
    }

    var modelClass = models[0].constructor;
    var idProperty = modelClass.getIdProperty();

    return _lodash2.default.sortBy(models, _lodash2.default.isArray(idProperty) ? idProperty : [idProperty]);
  };

  /**
   * @protected
   */


  Relation.prototype.throwError = function throwError(message) {
    if (this.ownerModelClass && this.ownerModelClass.name && this.name) {
      throw new Error(this.ownerModelClass.name + '.relationMappings.' + this.name + ': ' + message);
    } else {
      throw new Error(this.constructor.name + ': ' + message);
    }
  };

  return Relation;
}(), (_applyDecoratedDescriptor(_class.prototype, 'fullOwnerCol', [_memoize2.default], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'fullOwnerCol'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'fullRelatedCol', [_memoize2.default], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'fullRelatedCol'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'relatedTableAlias', [_memoize2.default], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'relatedTableAlias'), _class.prototype)), _class);
exports.default = Relation;